<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixi.js basic example</title>
        <script src="js/vptree.js"></script>
        <script src="js/vpTreeString.js"></script>  
        <!-- <script src="js/smallData.js"></script>  -->      
        <script src="js/dataInfo.js"></script>       <!-- heavy ! -->
        <script src="js/Smooth-0.1.7.js"></script>  <!-- smoothy dmoney -->
        <script src="js/Polyline.js"></script>  <!-- smoothy dmoney -->
        <script src="js/Utils.js"></script>  <!-- smoothy dmoney -->
        <script src="js/smallestEnclosingCircle.js"></script>  <!-- circle -->
        <script src="js/dat.gui.min.js"></script>
        <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,400" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Roboto Condensed', sans-serif;
        }

        .nav {
            color: white;
            position: absolute;
            top: 0px;
            padding: 5px 0 0 5px;
        }

        .nav a {
            color: white;
            text-decoration: none;
            padding: 0 5px;
        }

        .nav .inactive {
            color: #ccc;
            cursor: default;
        }

        .info {
            color: white;
            position: absolute;
            bottom: 0px;
            text-transform: uppercase;
            padding: 0 0 15px 15px;
        }
        #info-attribution {
            text-transform: none;
        }
    </style>
 
 
 
</head>
<body>
    <div class="nav">
        <a href="draw" class="inactive">Draw</a> | <a href="drag">Swipe</a>
    </div>

    <script src="pixi.js"></script>
    <script>


    var loadedJson = false;
    

    Object.defineProperty(Array.prototype, 'chunkArray', {
    value: function(chunkSize) {
        var array=this;
        return [].concat.apply([],
            array.map(function(elem,i) {
                return i%chunkSize ? [] : [array.slice(i,i+chunkSize)];
            })
        );
    }
    });


    // Generic function to load a file asynchronously
    function readTextFile(file, callback) {
        loadedJson = false;
        //console.log('Requesting file:', file);
        var rawFile = new XMLHttpRequest();
        rawFile.overrideMimeType("application/json");
        rawFile.open("GET", file, true);
        rawFile.onreadystatechange = function() {
            if (rawFile.readyState === 4) {
                callback(rawFile.status, rawFile.responseText);
            }
        }
        rawFile.send(null);
    }

    // Update DOM elements with new data
    function updateMetadata(data) {
        if (data.locality) var topLine = data.locality;
        else if (data.admin3) var topLine = data.admin3;
        else if (data.admin2) var topLine = data.admin2;
        else if (data.admin1) var topLine = data.admin1;
        else var topLine = '';

        var attribution = data.attribution || '';
        var country = data.country || '';

        document.getElementById('info-attribution').innerText = attribution;
        document.getElementById('info-line1').innerText = topLine;
        document.getElementById('info-line2').innerText = country;
    }

    // Callback from AJAX request to get metadata for matched line
    // Because we don't have all the metadata yet, we sometimes get a 404
    // Therefore pull metadata from a random image from a list that we've built
    // that has known, existing filenames. The 404 section can eventually
    // be removed
    function updateMetadataCallback(code, data) {
        if (code == 200) {
            matchedMetadata = JSON.parse(data);
        }
        else if (code == 404) {
            var index = Math.floor(Math.random()*metadataIDList.length);
            var id = metadataIDList[index];
            readTextFile('metadata/' + id + '.json', updateMetadataCallback);
        }
    };




    //----------------------------------------------------------
    // vpTree creation 
    // from cached files: 

    // todo: completely remove dataObj
    // completely load polylines throught this
    // 

    var vptrees = [];
    var polylines = [];
    var polylineCount = [];

    function loadNextTree(){
        readTextFile('data/' + vpTreeToLoad + '.json', loadVPTree);
    }

    Array.prototype.append = function(array)
    {
        this.push.apply(this, array)
    }


    var jsonData;
    var dataParseCount = 0;
    var parseWorkToDo = false;
    var polylinesTemp = [];

    function parseLoadVPTree(){

        if (!parseWorkToDo){
            return;
        }


        // otherwise let's do some work (accross frames) 

        //console.log("doing some work! " +  dataParseCount + " of " + jsonData["polylines"].length);

        var start =  dataParseCount;
        var end = Math.min(jsonData["polylines"].length,  dataParseCount + 50);

        //------------------------------------------------ do some work 
        var polylinePoints = jsonData["polylines"];
        
        for (j = start; j < end; j++){
            dataobj.push(polylinePoints[j]);
            ptsTemp = [];
            var x = 0;
            var y = 0;
            for (k = 0; k < polylinePoints[j].length/2; k++){
                x = polylinePoints[j][k*2];                      // converted to be relative...
                y = polylinePoints[j][k*2+1];
                pt = [];
                pt[0] = x;
                pt[1] = y;
                ptsTemp.push(pt);
            }
            var p = createPolyline(ptsTemp);
            p.init(true);
            polylinesTemp.push(p);
            polylines.push(p);  
        }
        

        dataParseCount = end;

        //------------------------------------------------ 
        if (end === jsonData["polylines"].length){          // we did it! 

            parseWorkToDo = false;
            polylineCount.push(polylinePoints.length);
            vpTreeString = eval('(' + jsonData["vpTree"] + ')');
            vptrees.push(VPTreeFactory.load(polylinesTemp, dist, vpTreeString));        
            vpTreeToLoad++;
            if (vpTreeToLoad < 5){
                window.setTimeout(loadNextTree, 10000);
            }
        }

    }

    function loadVPTree(code, data) {
        
        polylinesTemp = [];
        jsonData = JSON.parse(data);
        dataParseCount = 0;
        parseWorkToDo = true;

       
    }

    var vpTreeToLoad = 0;
    readTextFile('data/' + vpTreeToLoad + '.json', loadVPTree);

    //----------------------------------------------------------
    


    // Temporary!
    // Load a list of existing meta data ids in case we try to request one
    // that doesn't exist yet (because we're still waiting on real data)
    var metadataIDList = [];
    readTextFile('metadata-id-list.json', function(code, data) {
        metadataIDList = JSON.parse(data);
    });


    //-------------------------------------------------------------------
    //------------------------------------------------------------------- GUI
    var myGui;
    var Gui = function() {
        this.lineColor = 0xe8f700;
        this.lineOpacity = 0.75;
        this.lineWidth = 4;
        this.lineShadow = false;
        this.shadowDistance = 3;
        this.shadowBlur = 4;

        this.pulseWidth = 2;
        this.pulseSpeed = 10;
        this.pulseOpacityLow = 0.2;
        this.pulseOpacityHigh = 0.9;

        this.scaleSize = 0.4;
        this.scaleSpeed = 0.05;
        this.translateSpeed = 0.1;
        this.showEnclosingCircle = false;

        this.imgFadeInSpeed = 0.01;
        this.imgFadeOutSpeed = 0.01;
        this.bgFadeInSpeed = 0.008;
        this.bgFadeOutSpeed = 0.015;
        
        this.loadFromCloud = true;
    };

    window.onload = function() {
        myGui = new Gui();

        var gui = new dat.GUI();
        var f1 = gui.addFolder('line');
        f1.addColor(myGui, 'lineColor');
        f1.add(myGui, 'lineOpacity', 0, 1);
        f1.add(myGui, 'lineWidth', 1, 10);
        var shadowToggle = f1.add(myGui, 'lineShadow');
        f1.add(myGui, 'shadowDistance', 0, 10);
        f1.add(myGui, 'shadowBlur', 0, 10);

        var f2 = gui.addFolder('pulse');
        f2.add(myGui, 'pulseWidth', 1, 10);
        f2.add(myGui, 'pulseOpacityLow', 0, 1);
        f2.add(myGui, 'pulseOpacityHigh', 0, 1);
        f2.add(myGui, 'pulseSpeed', 1, 20);

        var f3 = gui.addFolder('scale/translate');
        f3.add(myGui, 'scaleSize', 0.2, 0.5);
        f3.add(myGui, 'scaleSpeed', 0, 0.5);
        f3.add(myGui, 'translateSpeed', 0, 0.5);
        f3.add(myGui, 'showEnclosingCircle');
        
        var f4 = gui.addFolder('fade');
        f4.add(myGui, 'imgFadeInSpeed', 0, 0.2);
        f4.add(myGui, 'imgFadeOutSpeed', 0, 0.2);
        f4.add(myGui, 'bgFadeInSpeed', 0, 0.2);
        f4.add(myGui, 'bgFadeOutSpeed', 0, 0.2);

        // gui.add(myGui, 'loadFromCloud');
        
        gui.remember(myGui);

        shadowToggle.onFinishChange(updateLineShadow);
    };



    //-------------------------------------------------------------------
    //------------------------------------------------------------------- drawing related stuff
    var drawnCircle;
    var angleMatch = 0;
    var infoobj = JSON.parse(info);
    var dataobj = [];    ///= JSON.parse(data);

    var animatingCircle = {};
    var matchedMetadata = {};
    var textureHasLoaded = false;

    function returnPathForCircle(simpleArray){
        canvasPoints = [];
         for (var i = 0; i < simpleArray.length/2; i++){
            var tempX = simpleArray[i*2];
            var tempY = simpleArray[i*2+1];
           canvasPoints.push({
                x: tempX,
                y: tempY
            });
        }
        return canvasPoints;
    }

    function returnPathForArray(simpleArray){
        var path = [];
        for (var i = 0; i < simpleArray.length/2; i++){
            path[i] = {
                 x: simpleArray[i*2],
                y: simpleArray[i*2+1]
            };
        }
        return path;
    }

    function createPolyline(points) {
        ratio1D =  0.9;
        rotationInvariance =  Math.PI*2;
        normalPointCount =  80;
        normalSize = 200;
        var polyline = new Polyline(points);
        polyline.ratio1D = this.ratio1D;
        polyline.rotationInvariance = this.rotationInvariance;
        polyline.normalPointCount = this.normalPointCount;
        polyline.normalSize = this.normalSize;
        return polyline;
    }

    function returnNestedArray(simpleArray){
        var path = [];
        for (var i = 0; i < simpleArray.length/2; i++){
            input = [];
            input[0] = simpleArray[i*2];
            input[1] = simpleArray[i*2+1];
            path.push(input);
        }
        return path;
    }


    // // make data obj non relative: 
    // console.log('Make data obj non relative:', 'starting...');

    // for (i = 0; i < dataobj.length; i++){
    //     var x = 0;
    //     var y = 0;
    //     for (j = 0; j < dataobj[i].length/2; j++){
    //          x += dataobj[i][j*2];                      // converted to be relative...
    //          y += dataobj[i][j*2+1];
    //          dataobj[i][j*2] = x;
    //          dataobj[i][j*2+1] = y; 
    //     }
    // }

    // console.log('Make data obj non relative:', 'finished.');
    

    // convert to Polyline :) 
    // var polylines = [];
    // for (i = 0; i < dataobj.length; i++){
    //     ptsTemp = [];
    //     var x = 0;
    //     var y = 0;
    //     for (j = 0; j < dataobj[i].length/2; j++){
    //         x = dataobj[i][j*2];                      // converted to be relative...
    //         y = dataobj[i][j*2+1];
    //         pt = [];
    //         pt[0] = x;
    //         pt[1] = y;
    //         ptsTemp.push(pt);
    //     }
    //     var p = createPolyline(ptsTemp);
    //     p.init(true);
    //     polylines.push(p);
    //     //console.log(p);
    // }

    function dist(a, b) {
        return Utils.cosDistance(a.vector, b.vector);
    }


     function   rotate(vector1, radians) {
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        for (var i = 0; i < vector1.length/2; i++) {
                x = vector1[i*2];
                y = vector1[i*2+1];
                //var p = this.points[i];
                var qx = x * cos - y * sin;
                var qy = x * sin + y * cos;
                vector1[i*2] = qx;
                vector1[i*2+1] = qy;
         }
    }


    function distNormalizedLines(vector1, vector2) {
        var a = vector1;
        var b = vector2;
        var distance = 0;
        var weight = 0;
        for (var i = 0; i < a.length/2; i++){
            var pct = i / (a.length/2);
            var scalar = 1.0+ (1.0 - Math.sin(pct * Math.PI))*10000.0;
            distance +=    scalar * Math.sqrt((b[i*2] - a[i*2])*(b[i*2] - a[i*2]) +  (b[i*2+1] - a[i*2+1])*(b[i*2+1] - a[i*2+1])); 
            weight += scalar;
        }
        return distance / weight;
    }

    //--------------------------------------------
    // split data obj 5 ways and make 5 vantage point trees. 
    // to test if checking against 5 is as good as checking one...
    //console.log("making a split to test multi vp trees");

    // var vptrees = [];
    // var polylinesSplit = [];
    // var amount = Math.ceil(dataobj.length / 5);
    // var dataObjChunked = dataobj.chunkArray(amount);
    // for (var i = 0; i < dataObjChunked.length; i++){

    //     var polylinesTemp = [];
    //     for (j = 0; j < dataObjChunked[i].length; j++){
    //         ptsTemp = [];
    //         var x = 0;
    //         var y = 0;
    //         for (k = 0; k < dataObjChunked[i][j].length/2; k++){
    //             x = dataObjChunked[i][j][k*2];                      // converted to be relative...
    //             y = dataObjChunked[i][j][k*2+1];
    //             pt = [];
    //             pt[0] = x;
    //             pt[1] = y;
    //             ptsTemp.push(pt);
    //         }
    //         var p = createPolyline(ptsTemp);
    //         p.init(true);
    //         polylinesTemp.push(p);
    //         //console.log(p);
    //     }
    //     polylinesSplit.push(polylinesTemp);
    //     vptrees.push(VPTreeFactory.build(polylinesSplit[i], dist));
    // }

    // this was used to export the data
    // for (var i = 0; i < dataObjChunked.length; i++){
    //      var objectForExport = {};
    //      objectForExport["polylines"] =  dataObjChunked[i];
    //      objectForExport["vpTree"] = vptrees[i].stringify();
    //      console.log(JSON.stringify(objectForExport));
    // }
    //  console.log(JSON.stringify(dataObjChunked[0]));
    //  console.log(JSON.stringify(polylinesSplit[0]));



    //console.log("done making a split to test multi vp trees " + vptrees.length);
    
    //--------------------------------------------

    // var vptree;
    // //vptree = VPTreeFactory.build(polylines, dist);

    // //var newType = {};


    // console.log('VPTreeFactory.load():', 'starting...');
    // vptree = VPTreeFactory.load(polylines,dist,vpTreeString );

    // //console.log(vptree.stringify());
    
    // console.log('VPTreeFactory.load():', 'finished.');
    //console.log(dataobj[0]);

    var drawing = false;
    var pts = [];
    var results = [];
    var ptsNew = [];

    var matched = false;
    pts = [];
    var linePulseCounter = 0;
    var bAmDrawing = false;
    var updateGraphics = false;
    var sprites = [];
    var backgroundImages = [];

    // Create the Renderer
    var w = window.innerWidth;
    var h = window.innerHeight;
    var renderer = PIXI.autoDetectRenderer(w, h, { backgroundColor : 0x000000, antialias: true });
    renderer.view.style.display = "block";
    document.body.appendChild(renderer.view);

    // Create the Stage, which is our root node of the scene
    var stage = new PIXI.Stage(0xFFFFFF, true);
    stage.interactive = true;
    stage.hitArea = new PIXI.Rectangle(0, 0, w, h);

    // Handle device orientation change
    // window.addEventListener("deviceorientation", function() {
    //     console.log('orientation change!', window.orientation);
    //     console.log('inner width:', window.innerWidth, 'inner height:', window.innerHeight);
    //     renderer.resize(window.innerWidth, window.innerHeight);
    //     stage.hitArea = new PIXI.Rectangle(window.innerWidth, window.innerHeight);
    // }, true);

    // Line drawn out by the user
    var dropShadowFilter = new PIXI.filters.DropShadowFilter();
    var drawing = new PIXI.Graphics();
    stage.addChild(drawing);
    drawing.position.x = 0;
    drawing.position.y = 0;

    function updateLineShadow(val) {
        drawing.filters = val ? [ dropShadowFilter ] : null;
    }


    // loading: 
    var text = new PIXI.Text('Loading',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
    stage.addChild(text);
    text.position.x = 300;
    text.position.y = 300;


    var circleOffsetX;
    var circleOffsetY;
    var circleScaleRatio;
    var touchID;
    
    //------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------
    stage.mousedown = stage.touchstart = function(moveData) {



        bAmDrawing = true;
        linePulseCounter = 0;
        textureHasLoaded = false;
        pts = [];
        matched = false;
        pts.push(moveData.data.global.x); //renderer.plugins.interaction.mouse.global.x);
        pts.push(moveData.data.global.y); //renderer.plugins.interaction.mouse.global.y);

        // Clear metadata by updating it with an empty object
        updateMetadata({});
    };

    stage.mousemove = stage.touchmove = function(moveData) {

        if (bAmDrawing === true){


                 pts.push(moveData.data.global.x); //renderer.plugins.interaction.mouse.global.x);
                 pts.push(moveData.data.global.y); //renderer.plugins.interaction.mouse.global.y);
                
                if (pts.length > 60*2){
                        pts.shift();
                        pts.shift();
                 } 

                updateGraphics = true;

        }
        
    };

    stage.mouseup = stage.mouseupoutside = stage.touchend = stage.touchendoutside = function(moveData) {

        // if we weren't drawing (gui, etc) return;
         if (bAmDrawing === false){
            return;
        }


        bAmDrawing = false;

        // resample if we need to: 
        var ptsResampled = [];

        if (pts.length != 120){
            var xPts = [];
            var yPts = [];
            for (var i = 0; i < pts.length/2; i++){
                x = pts[i*2];
                y = pts[i*2+1];
                xPts[i] = x;
                yPts[i] = y;
            }
            //ptsResampled = [];       
            var xSmooth = Smooth(xPts);
            var ySmooth = Smooth(yPts);
            for (var i = 0; i < 60; i++){
                pctMe = i / 59.0;
                var newX = xSmooth(pctMe * (xPts.length -1));
                var newY = ySmooth(pctMe * (yPts.length -1));
                ptsResampled[i*2] = newX;
                ptsResampled[i*2+1] = newY;
            }
        } else {
            for (var i = 0; i < pts.length; i++){
                ptsResampled.push(pts[i]);
            }
        }

        ptsTemp = [];
        for (j = 0; j < ptsResampled.length/2; j++){
            x = ptsResampled[j*2];
            y = ptsResampled[j*2+1];
            pt = [];
            pt[0] = x;
            pt[1] = y;
            ptsTemp.push(pt);
        }

        ptsTemp2 = [];
        for (j = 0; j < ptsResampled.length/2; j++){
            x = ptsResampled[j*2];
            y = ptsResampled[j*2+1];
            pt = [];
            pt[0] = x;
            pt[1] = y;
            ptsTemp2.push(pt);
        }
        ptsTemp2.reverse();

        // make a circle so we can scale this circle 
        drawnCircle = makeCircle(returnPathForArray(ptsResampled));
        var p = createPolyline(ptsTemp);
        var p2 = createPolyline(ptsTemp2);
        p.init(true);
        p2.init(true);
        var resultsA; //= vptree.search(p, 1);
        //console.log('resultsA:', resultsA[0]);
        var resultsB; // = vptree.search(p2, 1);
        //console.log('resultsB:', resultsB[0]);

        if (vptrees.length == 0){
            console.log("we are still loading data, returning");
            return;
        }

        // check the multiple trees: 
        var minA = 1000000.0;
        var minAindex = -1;
        var minAnum = -1;

        var minB = 1000000.0;
        var minBindex = -1;
        var minBnum = -1;

        for (var i = 0; i < vptrees.length; i++){

            var multiResultsA = vptrees[i].search(p, 1);
            console.log('multiResultsA:', multiResultsA[0]);
            var multiResultsB = vptrees[i].search(p2, 1);
            console.log('multiResultsB:', multiResultsB[0]);

            if (i === 0){
                resultsA = multiResultsA;
                resultsB = multiResultsB;
            }

            if (multiResultsA[0].d < minA){
                minA = multiResultsA[0].d ;
                minAindex =  multiResultsA[0].i;
                minANum = i;
            }

            if (multiResultsB[0].d < minB){
                minB = multiResultsB[0].d ;
                minBindex =  multiResultsB[0].i;
                minBNum = i;
            }
        }

        var whichOneA = 0;
        var whichOneB = 0;

        for (var i = 0; i < minANum; i++){
            whichOneA += polylineCount[i];
        }
        whichOneA += minAindex;

        for (var i = 0; i < minBNum; i++){
            whichOneB += polylineCount[i];
        }
        whichOneB += minBindex;
        
        console.log(minA + " " + minB + " " + whichOneA + " " + whichOneB);

        console.log("overwriting original results");    


        resultsA[0].i = whichOneA;
        resultsA[0].d = minA;

        resultsB[0].i = whichOneB;
        resultsB[0].d = minB;
        
        console.log("done overwriting original results");

    
        if (resultsB[0].d < resultsA[0].d){
            results = resultsB;
            //pts.reverse();
            // reverse pair of two
            for (j = 0; j < pts.length/2; j++){
                ptsResampled[j*2] = ptsTemp2[j][0];
                ptsResampled[j*2+1] = ptsTemp2[j][1];
            }      

        } else {
            results = resultsA;
        }

        console.log('results:', results[0]);


        var ptsScaled = ptsResampled.slice();
        var scaleMe = scale = 250.0 / drawnCircle.r;
        for (j = 0; j < ptsScaled.length/2; j++){
            ptsScaled[j*2] -= drawnCircle.x;
            ptsScaled[j*2+1] -= drawnCircle.y;
            ptsScaled[j*2] *= scaleMe;
            ptsScaled[j*2+1] *= scaleMe;
                 
        }



        var bestAngle = 0;
        var smallestDiff = 10000000;
        for (var i = 0; i < 300; i++){
            var angle = (i/300.0) * Math.PI * 2;
            var ptsRotated = dataobj[results[0].i].slice(0);

            rotate(ptsRotated, angle);
            rotatedDist = distNormalizedLines(ptsScaled, ptsRotated);

            if (rotatedDist < smallestDiff){
                smallestDiff = rotatedDist;
                bestAngle = angle;
            }
           
        }

        var id = infoobj[results[0].i][0];
        readTextFile('metadata/' + id + '.json', updateMetadataCallback);


        //console.log( infoobj[results[0].i] );

        angleMatch = bestAngle;
        updateGraphics = true;


        console.log('TextureCache:', PIXI.utils.TextureCache);

        var random = Math.floor(Math.random()*1000);

        // Create a new Texture and Sprite from the matched image
        if (myGui.loadFromCloud)
            var url = 'http://storage.googleapis.com/navigator-media-usa/media/draw/v1/';
        else
            var url = '/';
        
        PIXI.loader.reset();

        console.log("loading num : "  + infoobj[results[0].i][0]);

        var texture = PIXI.Texture.fromImage(url + 'full/' + infoobj[results[0].i][0] + '.jpg');
        var sprite = new PIXI.Sprite(texture);
        sprite.alpha = 0;

        // Add the new Sprite to the stage
        // Old Sprits will fade out, calculated in animate()
        sprites.push(sprite);
        stage.addChild(sprite);

        // Move drawn line on top of images
        stage.removeChild(drawing);
        stage.addChild(drawing);

        // Positioning for matched image
        sprite.position.x = drawnCircle.x;
        sprite.position.y = drawnCircle.y;
        sprite.rotation = angleMatch;
        sprite.scale.x = drawnCircle.r / infoobj[results[0].i][3];
        sprite.scale.y = drawnCircle.r / infoobj[results[0].i][3];

        xPosOrig = infoobj[results[0].i][1];
        yPosOrig = infoobj[results[0].i][2];

        sprite.anchor.x = xPosOrig / 1800.0;
        sprite.anchor.y = yPosOrig / 1200.0;

        sprite.originalPosition = {};
        sprite.originalPosition.x = sprite.position.x;
        sprite.originalPosition.y = sprite.position.y;
        sprite.originalScale = sprite.scale.x;

        animatingCircle.x = drawnCircle.x;
        animatingCircle.y = drawnCircle.y;
        animatingCircle.r = drawnCircle.r;

        // Update background image
        PIXI.loader.reset();
        var bg = new PIXI.Sprite.fromImage(url + 'blurredImages/' + infoobj[results[0].i][0] + '.jpg');
        bg.alpha = 0;
        // TODO Properly scale the background image to cover the background while maintaing
        // its aspect ratio. For now just stretch to fill
        bg.width = renderer.view.width;
        bg.height = renderer.view.height;
        backgroundImages.push(bg);
        stage.addChildAt(bg, 0);

        matched = true;

    //----------------------------

    }; 



    //------------------------------------------------------------------------------------------------

    animate();
    //requestAnimationFrame(animate);

    //console.log(sprite1.texture);

    var timef = 0;

    function animate() {
        

        parseLoadVPTree();  // always try to parse ! 


        if (vptrees.length > 0){
            text.position.x = -1000;
        }


        if (drawing === false && 
            matched === true){
            updateGraphics === true;
        }

        //------------------------------------------------------- drawing
        if (updateGraphics === true){
            drawing.clear();

            //console.log(drawing);
            dropShadowFilter.blur = myGui.shadowBlur;
            dropShadowFilter.distance = myGui.shadowDistance;

            if (!matched){
                drawing.lineStyle(myGui.lineWidth, myGui.lineColor, myGui.lineOpacity);

                for (var i = 0; i < pts.length/2; i++){
                    if (i == 0){
                        drawing.moveTo(pts[0], pts[1]);
                    } else {
                        drawing.lineTo(pts[i*2], pts[i*2+1]);
                    }
                }

                // Fade out old images to halfway
                for (var i = 0; i < sprites.length; i++) {
                    if (sprites[i].alpha >= 0.5) {
                        sprites[i].alpha -= myGui.imgFadeOutSpeed;
                    }
                }
                // Fade out background images
                for (var i = 0; i < backgroundImages.length; i++) {
                    backgroundImages[i].alpha -= myGui.bgFadeOutSpeed;
                }

            } else {

                // Update metadata UI when the texture loads
                //console.log('Updating metadata UI, sprites length is:', sprites.length);
                if (sprites[sprites.length-1].texture.baseTexture &&
                    sprites[sprites.length-1].texture.baseTexture.hasLoaded) {
                    if (!textureHasLoaded) {
                        console.log('Texture just finished loading!');
                        textureHasLoaded = true;
                        updateMetadata(matchedMetadata);
                    }
                }

                // Set the line style based on our state
                // If the texture is loading, then it should pulse
                // Otherwise it's solid
                if (textureHasLoaded) {
                    drawing.lineStyle(myGui.lineWidth, myGui.lineColor, myGui.lineOpacity);
                } else {
                    linePulseCounter += (0.01 * myGui.pulseSpeed);
                    var sine = Math.sin(linePulseCounter);
                    var thickness = Utils.remap(sine, -1, 1, myGui.lineWidth - myGui.pulseWidth, myGui.lineWidth + myGui.pulseWidth);
                    var opacity = Utils.remap(sine, -1, 1, myGui.pulseOpacityLow, myGui.pulseOpacityHigh);
                    drawing.lineStyle(thickness, myGui.lineColor, opacity);
                }   



                var translateSpeed = myGui.translateSpeed;
                var scaleSpeed = myGui.scaleSpeed;

                var targetX = renderer.view.width * 0.5;
                var targetY = renderer.view.height * 0.5;
                if (renderer.view.width > renderer.view.height)
                    var targetR = renderer.view.height * myGui.scaleSize;
                else
                    var targetR = renderer.view.width * myGui.scaleSize;

                // Make sure the most recent matched image has loaded
                // Then begin calculating a lerped toward the target
                if (sprites[sprites.length-1].texture.baseTexture &&
                    sprites[sprites.length-1].texture.baseTexture.hasLoaded) {
                    animatingCircle.x = animatingCircle.x * (1 - translateSpeed) + targetX * translateSpeed;
                    animatingCircle.y = animatingCircle.y * (1 - translateSpeed) + targetY * translateSpeed;
                    animatingCircle.r = animatingCircle.r * (1 - scaleSpeed) + targetR * scaleSpeed;
                }

                // Update offsets/scale ratios to move drawing line & image toward center
                circleOffsetX = animatingCircle.x - drawnCircle.x;
                circleOffsetY = animatingCircle.y - drawnCircle.y;
                circleScaleRatio = animatingCircle.r / drawnCircle.r;

                for (var i = 0; i < pts.length/2; i++){

                    // this is how we could scale and change the offset of the line.  zooming in to center seems good
                    // image can do the same thing since it's also set by drawn circle (above the end of mouse released)
                    
                    var x = pts[i*2] - drawnCircle.x;
                    var y = pts[i*2+1] - drawnCircle.y;

                    x *= circleScaleRatio;
                    y *= circleScaleRatio;

                    x += drawnCircle.x;
                    y += drawnCircle.y;

                    x += circleOffsetX;
                    y += circleOffsetY;


                    if (i == 0){
                        drawing.moveTo(x,y);
                    } else {
                        drawing.lineTo(x,y);
                    }
                }

                // Draw enclosing circle
                if (myGui.showEnclosingCircle) {
                    drawing.lineStyle(4, 0xff0000, 0.5);
                    drawing.drawCircle(animatingCircle.x, animatingCircle.y, animatingCircle.r);
                }
            }

            // Fade out old images
            if (sprites.length) {
                var endingIndex = bAmDrawing ? sprites.length - 1 : sprites.length - 2;
                for (var i = 0; i <= endingIndex; i++) {
                    sprites[i].alpha -= myGui.imgFadeOutSpeed;
                }
                // Fade in most recent image
                if (sprites[sprites.length-1].alpha < 1) {
                    sprites[sprites.length-1].alpha += myGui.imgFadeInSpeed;

                    // Make sure it doesn't exceed 1.0
                    if (sprites[sprites.length-1].alpha > 1)
                        sprites[sprites.length-1].alpha = 1;
                }

                // Remove invisible Sprites
                // Work in reverse to avoid the delete-while-iterating problem
                for (var i = sprites.length-1; i >= 0; i--) {
                    if (sprites[i].alpha <= 0) {
                        // Delete 1 element at this index
                        stage.removeChild(sprites[i]);
                        sprites[i].texture.destroy(true);
                        sprites[i].destroy();
                        sprites.splice(i, 1);
                    }
                }
            }

            // Fade out background images
            console.log()
            if (backgroundImages.length) {
                var endingIndex = bAmDrawing ? backgroundImages.length - 1 : backgroundImages.length - 2;
                for (var i = 0; i <= endingIndex; i++) {
                    backgroundImages[i].alpha -= myGui.bgFadeOutSpeed;
                }
                // Fade in most recent image
                if (backgroundImages[backgroundImages.length-1].alpha < 1) {
                    backgroundImages[backgroundImages.length-1].alpha += myGui.bgFadeInSpeed;

                    // Make sure it doesn't exceed 1.0
                    if (backgroundImages[backgroundImages.length-1].alpha > 1)
                        backgroundImages[backgroundImages.length-1].alpha = 1;
                }

                // Remove invisible Sprites
                // Work in reverse to avoid the delete-while-iterating problem
                for (var i = backgroundImages.length-1; i >= 0; i--) {
                    if (backgroundImages[i].alpha <= 0) {
                        // Delete 1 element at this index
                        stage.removeChild(backgroundImages[i]);
                        backgroundImages[i].destroy();
                        backgroundImages.splice(i, 1);
                    }
                }
            }

            // Scale & translate most recent matched image toward center
            if (sprites.length && !bAmDrawing) {
                var index = sprites.length - 1;
                sprites[index].position.x = sprites[index].originalPosition.x + circleOffsetX;
                sprites[index].position.y = sprites[index].originalPosition.y + circleOffsetY;

                var scale = sprites[index].originalScale * circleScaleRatio;
                sprites[index].scale.set(scale, scale);
            }
            

            // for (var i = 0; i < Math.min(results.length,1); i++){
            //         var index = results[i].i;
            //         var tempMe = dataobj[index].slice(0);
            //          rotate(tempMe, angleMatch);

            //         for (var j = 0; j < tempMe.length; j++){
            //             if (j == 0) 
            //                  drawing.moveTo(tempMe[j*2]*0.1 + (i%16+1) * 80, tempMe[j*2+1]*0.1 + Math.floor(i/16 + 1) * 80 );
            //             else 
            //                  drawing.lineTo( tempMe[j*2]*0.1 + (i%16+1) * 80, tempMe[j*2+1]*0.1 + Math.floor(i/16 + 1) * 80 );                
            //         }
            //         //this.stroke();
                   

            //     }

            // for (var i = 0; i < pts.length; i++){
            //     if (i == 0){
            //         drawing.moveTo(pts[0][0] + 100, pts[0][1]);
            //     } else {
            //         drawing.lineTo(pts[i][0] + 100, pts[i][1]);
            //     }
            // }

            // Only update graphics on next pass if there is something
            // to animate

            // Keep this on for now since GUI changes won't take affect if we're not rendering
            // updateGraphics = false;
            updateGraphics = true;

            //      if (bAmDrawing && sprites.length > 0) updateGraphics = true;
            // else if (sprites.length > 1) updateGraphics = true;
            // else if (sprites.length && !sprites[sprites.length-1].texture.baseTexture.hasLoaded) updateGraphics = true;
            // else if (Math.abs(animatingCircle.x - targetX) > 1) updateGraphics = true;
            // else if (Math.abs(animatingCircle.y - targetY) > 1) updateGraphics = true;
            // else if (Math.abs(animatingCircle.r - targetR) > 1) updateGraphics = true;
         }
        renderer.render(stage);
        requestAnimationFrame( animate );
    }
    </script>

    <div class="info">
        <div id="info-line1"></div>
        <div id="info-line2"></div>
        <div id="info-attribution"></div>
    </div>

</body>
</html>