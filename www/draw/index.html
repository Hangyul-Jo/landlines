<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Pixi.js basic example</title>
        <script src="js/vptree.js"></script>
       <script src="js/vpTreeString.js"></script>  
        <script src="js/smallData.js"></script>       
        <script src="js/dataInfo.js"></script>       <!-- heavy ! -->
        <script src="js/Smooth-0.1.7.js"></script>  <!-- smoothy dmoney -->
        <script src="js/Polyline.js"></script>  <!-- smoothy dmoney -->
        <script src="js/Utils.js"></script>  <!-- smoothy dmoney -->
        <script src="js/smallestEnclosingCircle.js"></script>  <!-- circle -->
        <script src="js/vpTreeString.js"></script>  <!-- circle -->
        <script src="js/dat.gui.min.js"></script>
<style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
        }
    </style>
 
 
 
</head>
<body>
    <script src="pixi.js"></script>
    <script>


    var loadedJson = false;

    function readTextFile(file, callback) {
        loadedJson = false;
        console.log("start loading text");
        var rawFile = new XMLHttpRequest();
        rawFile.overrideMimeType("application/json");
        rawFile.open("GET", file, true);
        rawFile.onreadystatechange = function() {
            if (rawFile.readyState === 4 && rawFile.status == "200") {
                callback(rawFile.responseText);
            }
        }
        rawFile.send(null);
    }


    //-------------------------------------------------------------------
    //------------------------------------------------------------------- GUI
    var myGui;
    var Gui = function() {
        this.pulseSpeed = 7;
        this.scaleSize = 0.4;
        this.scaleSpeed = 0.05;
        this.translateSpeed = 0.1;
        this.fadeSpeed = 0.01;
        this.showEnclosingCircle = false;
        this.loadFromCloud = true;
    };

    window.onload = function() {
        myGui = new Gui();
        var gui = new dat.GUI();
        gui.add(myGui, 'pulseSpeed', 1, 10);
        gui.add(myGui, 'scaleSize', 0.2, 0.5);
        gui.add(myGui, 'scaleSpeed', 0, 0.5);
        gui.add(myGui, 'translateSpeed', 0, 0.5);
        gui.add(myGui, 'fadeSpeed', 0, 0.2);
        gui.add(myGui, 'showEnclosingCircle');
        gui.add(myGui, 'loadFromCloud');
    };



    //-------------------------------------------------------------------
    //------------------------------------------------------------------- drawing related stuff
    var drawnCircle;
    var angleMatch = 0;
    var infoobj = JSON.parse(info);
    var dataobj = JSON.parse(data);

    var animatingCircle = {};

    function returnPathForCircle(simpleArray){
        canvasPoints = [];
         for (var i = 0; i < simpleArray.length/2; i++){
            var tempX = simpleArray[i*2];
            var tempY = simpleArray[i*2+1];
           canvasPoints.push({
                x: tempX,
                y: tempY
            });
        }
        return canvasPoints;
    }

    function returnPathForArray(simpleArray){
        var path = [];
        for (var i = 0; i < simpleArray.length/2; i++){
            path[i] = {
                 x: simpleArray[i*2],
                y: simpleArray[i*2+1]
            };
        }
        return path;
    }

    function createPolyline(points) {
        ratio1D =  0.9;
        rotationInvariance =  Math.PI*2;
        normalPointCount =  80;
        normalSize = 200;
        var polyline = new Polyline(points);
        polyline.ratio1D = this.ratio1D;
        polyline.rotationInvariance = this.rotationInvariance;
        polyline.normalPointCount = this.normalPointCount;
        polyline.normalSize = this.normalSize;
        return polyline;
    }

    function returnNestedArray(simpleArray){
        var path = [];
        for (var i = 0; i < simpleArray.length/2; i++){
            input = [];
            input[0] = simpleArray[i*2];
            input[1] = simpleArray[i*2+1];
            path.push(input);
        }
        return path;
    }


    // make data obj non relative: 
    console.log("start");

    for (i = 0; i < dataobj.length; i++){
        var x = 0;
        var y = 0;
        for (j = 0; j < dataobj[i].length/2; j++){
             x += dataobj[i][j*2];                      // converted to be relative...
             y += dataobj[i][j*2+1];
             dataobj[i][j*2] = x;
             dataobj[i][j*2+1] = y; 
        }
    }

    console.log("end");
    

    // convert to Polyline :) 
    var polylines = [];
    for (i = 0; i < dataobj.length; i++){
        ptsTemp = [];
        var x = 0;
        var y = 0;
        for (j = 0; j < dataobj[i].length/2; j++){
            x = dataobj[i][j*2];                      // converted to be relative...
            y = dataobj[i][j*2+1];
            pt = [];
            pt[0] = x;
            pt[1] = y;
            ptsTemp.push(pt);
        }
        var p = createPolyline(ptsTemp);
        p.init(true);
        polylines.push(p);
        //console.log(p);
    }

    function dist(a, b) {
        return Utils.cosDistance(a.vector, b.vector);
    }


     function   rotate(vector1, radians) {
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        for (var i = 0; i < vector1.length/2; i++) {
                x = vector1[i*2];
                y = vector1[i*2+1];
                //var p = this.points[i];
                var qx = x * cos - y * sin;
                var qy = x * sin + y * cos;
                vector1[i*2] = qx;
                vector1[i*2+1] = qy;
         }
    }


    function distNormalizedLines(vector1, vector2) {
        var a = vector1;
        var b = vector2;
        var distance = 0;
        for (var i = 0; i < a.length/2; i++){
            distance +=    Math.sqrt((b[i*2] - a[i*2])*(b[i*2] - a[i*2]) +  (b[i*2+1] - a[i*2+1])*(b[i*2+1] - a[i*2+1])); 
        }
        return distance / 60.0;
    }

    var vptree;
    //vptree = VPTreeFactory.build(polylines, dist);

    //var newType = {};


    vptree = VPTreeFactory.load(polylines,dist,vpTreeString );

    //console.log(vptree.stringify());
    
    console.log("ending");    
    //console.log(dataobj[0]);

    var drawing = false;
    var pts = [];
    var results = [];
    var ptsNew = [];

    var matched = false;
    pts = [];
    var linePulseCounter = 0;
    var bAmDrawing = false;
    var updateGraphics = false;
    var sprites = [];

    // Create the Renderer
    var w = window.innerWidth;
    var h = window.innerHeight;
    var renderer = PIXI.autoDetectRenderer(w, h, { backgroundColor : 0x000000 });
    renderer.view.style.display = "block";
    document.body.appendChild(renderer.view);

    // Create the Stage, which is our root node of the scene
    var stage = new PIXI.Stage(0xFFFFFF, true);
    stage.interactive = true;
    stage.hitArea = new PIXI.Rectangle(0, 0, w, h);

    // Handle device orientation change
    window.addEventListener("deviceorientation", function() {
        console.log('orientation change!', window.orientation);
        console.log('inner width:', window.innerWidth, 'inner height:', window.innerHeight);
        renderer.resize(window.innerWidth, window.innerHeight);
        stage.hitArea.set(window.innerWidth, window.innerHeight);
    }, true);

    // Line drawn out by the user
    var drawing = new PIXI.Graphics();
    stage.addChild(drawing);
    drawing.position.x = 0;
    drawing.position.y = 0;

    var circleOffsetX;
    var circleOffsetY;
    var circleScaleRatio;
    
    //------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------
    stage.mousedown = stage.touchstart = function(moveData) {

        console.log("start");
        // var random = Math.floor(Math.random()*1000);
        // texture = PIXI.Texture.fromImage('full/' + random + '.jpg');
        // sprite1 = new PIXI.Sprite(texture);
        // stage.removeChild(sprite1);
        // stage.addChild(sprite1);


        console.log(moveData.data.global.x); //renderer.plugins.interaction);

        bAmDrawing = true;
        linePulseCounter = 0;
        pts = [];
        matched = false;
        pts.push(moveData.data.global.x); //renderer.plugins.interaction.mouse.global.x);
        pts.push(moveData.data.global.y); //renderer.plugins.interaction.mouse.global.y);
    };

    stage.mousemove = stage.touchmove = function(moveData) {

         console.log("move");
        if (bAmDrawing === true){
                 pts.push(moveData.data.global.x); //renderer.plugins.interaction.mouse.global.x);
                 pts.push(moveData.data.global.y); //renderer.plugins.interaction.mouse.global.y);
                
                if (pts.length > 60*2){
                        pts.shift();
                        pts.shift();
                 } 

                updateGraphics = true;

        }
        
    };

    stage.mouseup = stage.mouseupoutside = stage.touchend = stage.touchendoutside = function(moveData) {
        bAmDrawing = false;

        //-----------------------------------------------------

        if (pts.length != 120){

                    var xPts = [];
                    var yPts = [];

                    for (var i = 0; i < pts.length/2; i++){
                        x = pts[i*2];
                        y = pts[i*2+1];
                        xPts[i] = x;
                        yPts[i] = y;
                    }

                    pts = [];       

                    var xSmooth = Smooth(xPts);
                    var ySmooth = Smooth(yPts);

                    for (var i = 0; i < 60; i++){
                        pctMe = i / 59.0;
                        var newX = xSmooth(pctMe * (xPts.length -1));
                        var newY = ySmooth(pctMe * (yPts.length -1));

                        pts[pts.length] = newX;
                        pts[pts.length] = newY;
                           
                    }

                }



                ptsTemp = [];
                for (j = 0; j < pts.length/2; j++){
                    x = pts[j*2];
                    y = pts[j*2+1];
                    pt = [];
                    pt[0] = x;
                    pt[1] = y;
                    ptsTemp.push(pt);
                }


                ptsTemp2 = [];
                for (j = 0; j < pts.length/2; j++){
                    x = pts[j*2];
                    y = pts[j*2+1];
                    pt = [];
                    pt[0] = x;
                    pt[1] = y;
                    ptsTemp2.push(pt);
                }

                ptsTemp2.reverse();

                // make a circle so we can scale this circle 
                drawnCircle = makeCircle(returnPathForArray(pts));
                var p = createPolyline(ptsTemp);
                var p2 = createPolyline(ptsTemp2);
                p.init(true);
                p2.init(true);
                resultsA = vptree.search(p, 1);

                console.log(results[0]);

                resultsB = vptree.search(p2, 1);

                console.log(results[0]);

                if (resultsB[0].d < resultsA[0].d){
                    results = resultsB;
                    //pts.reverse();
                    // reverse pair of two
                    for (j = 0; j < pts.length/2; j++){
                        pts[j*2] = ptsTemp2[j][0];
                        pts[j*2+1] = ptsTemp2[j][1];
                    }      

                } else {
                    results = resultsA;
                }


                var ptsScaled = pts.slice();
                var scaleMe = scale = 250.0 / drawnCircle.r;
                for (j = 0; j < ptsScaled.length/2; j++){
                    ptsScaled[j*2] -= drawnCircle.x;
                    ptsScaled[j*2+1] -= drawnCircle.y;
                    ptsScaled[j*2] *= scaleMe;
                    ptsScaled[j*2+1] *= scaleMe;
                         
                }



                var bestAngle = 0;
                var smallestDiff = 10000000;
                for (var i = 0; i < 300; i++){
                    var angle = (i/300.0) * Math.PI * 2;
                    var ptsRotated = dataobj[results[0].i].slice(0);

                    rotate(ptsRotated, angle);
                    rotatedDist = distNormalizedLines(ptsScaled, ptsRotated);

                    if (rotatedDist < smallestDiff){
                        smallestDiff = rotatedDist;
                        bestAngle = angle;
                    }
                   
                }

                //console.log( infoobj[results[0].i] );

                angleMatch = bestAngle;
                updateGraphics = true;


                console.log(PIXI.TextureCache);

                var random = Math.floor(Math.random()*1000);

                // Create a new Texture and Sprite from the matched image
                if (myGui.loadFromCloud)
                    var url = 'http://storage.googleapis.com/navigator-media-usa/media/draw/v1/full/';
                else
                    var url = 'full/';
                var texture = PIXI.Texture.fromImage(url + infoobj[results[0].i][0] + '.jpg');

                var sprite = new PIXI.Sprite(texture);

                // Add the new Sprite to the stage
                // Old Sprits will fade out, calculated in animate()
                sprites.push(sprite);
                stage.addChild(sprite);

                // Move drawn line on top of images
                stage.removeChild(drawing);
                stage.addChild(drawing);

                // Positioning for matched image
                sprite.position.x = drawnCircle.x;
                sprite.position.y = drawnCircle.y;
                sprite.rotation = angleMatch;
                sprite.scale.x = drawnCircle.r / infoobj[results[0].i][3];
                sprite.scale.y = drawnCircle.r / infoobj[results[0].i][3];

                xPosOrig = infoobj[results[0].i][1];
                yPosOrig = infoobj[results[0].i][2];

                sprite.anchor.x = xPosOrig / 1800.0;
                sprite.anchor.y = yPosOrig / 1200.0;

                sprite.originalPosition = {};
                sprite.originalPosition.x = sprite.position.x;
                sprite.originalPosition.y = sprite.position.y;
                sprite.originalScale = sprite.scale.x;

                animatingCircle.x = drawnCircle.x;
                animatingCircle.y = drawnCircle.y;
                animatingCircle.r = drawnCircle.r;

                matched = true;
                
                //sprite1.scale.x =  1.0;

            //----------------------------

    }; 



    //------------------------------------------------------------------------------------------------
    
    // stage.click = stage.tap = function()
    // {
    // }

    animate();
    //requestAnimationFrame(animate);

    //console.log(sprite1.texture);

    var timef = 0;

    function animate() {
            
        if (drawing === false && 
            matched === true){
            updateGraphics === true;
        }

        //------------------------------------------------------- drawing
        if (updateGraphics === true){
            drawing.clear();

            if (!matched){
                drawing.lineStyle(4, 0xffffff, 1);

                for (var i = 0; i < pts.length/2; i++){
                    if (i == 0){
                        drawing.moveTo(pts[0], pts[1]);
                    } else {
                        drawing.lineTo(pts[i*2], pts[i*2+1]);
                    }
                }
            } else {

                if (sprites[sprites.length-1].texture.baseTexture.hasLoaded)
                    drawing.lineStyle(4, 0xffffff, 1);
                else {
                    linePulseCounter += (0.01 * myGui.pulseSpeed);
                    var sine = Math.sin(linePulseCounter);
                    var thickness = (sine + 3) * 2;
                    drawing.lineStyle(thickness, 0xffffff, 1);
                }

                var translateSpeed = myGui.translateSpeed;
                var scaleSpeed = myGui.scaleSpeed;

                var targetX = renderer.view.width * 0.5;
                var targetY = renderer.view.height * 0.5;
                if (renderer.view.width > renderer.view.height)
                    var targetR = renderer.view.height * myGui.scaleSize;
                else
                    var targetR = renderer.view.width * myGui.scaleSize;

                // Make sure the most recent matched image has loaded
                // Then begin calculating a lerped toward the target
                if (sprites[sprites.length-1].texture.baseTexture.hasLoaded) {
                    animatingCircle.x = animatingCircle.x * (1 - translateSpeed) + targetX * translateSpeed;
                    animatingCircle.y = animatingCircle.y * (1 - translateSpeed) + targetY * translateSpeed;
                    animatingCircle.r = animatingCircle.r * (1 - scaleSpeed) + targetR * scaleSpeed;
                }

                // Update offsets/scale ratios to move drawing line & image toward center
                circleOffsetX = animatingCircle.x - drawnCircle.x;
                circleOffsetY = animatingCircle.y - drawnCircle.y;
                circleScaleRatio = animatingCircle.r / drawnCircle.r;

                for (var i = 0; i < pts.length/2; i++){

                    // this is how we could scale and change the offset of the line.  zooming in to center seems good
                    // image can do the same thing since it's also set by drawn circle (above the end of mouse released)
                    
                    var x = pts[i*2] - drawnCircle.x;
                    var y = pts[i*2+1] - drawnCircle.y;

                    x *= circleScaleRatio;
                    y *= circleScaleRatio;

                    x += drawnCircle.x;
                    y += drawnCircle.y;

                    x += circleOffsetX;
                    y += circleOffsetY;


                    if (i == 0){
                        drawing.moveTo(x,y);
                    } else {
                        drawing.lineTo(x,y);
                    }
                }

                // Draw enclosing circle
                if (myGui.showEnclosingCircle) {
                    drawing.lineStyle(4, 0xff0000, 0.5);
                    drawing.drawCircle(animatingCircle.x, animatingCircle.y, animatingCircle.r);
                }
            }

            // Fade out old images
            if (sprites.length) {
                // If we're drawing then all images should get faded out
                // If we're not drawing, then the last image should stay but
                // everything else before it should get faded
                var endingIndex = bAmDrawing ? sprites.length - 1 : sprites.length - 2;
                for (var i = 0; i <= endingIndex; i++) {
                    sprites[i].alpha -= myGui.fadeSpeed;
                }
                // Remove invisible Sprites
                // Work in reverse to avoid the delete-while-iterating problem
                for (var i = sprites.length-1; i >= 0; i--) {
                    if (sprites[i].alpha <= 0) {
                        // Delete 1 element at this index
                        sprites.splice(i, 1);
                    }
                }
            }

            // Scale & translate most recent matched image toward center
            if (sprites.length && !bAmDrawing) {
                var index = sprites.length - 1;
                sprites[index].position.x = sprites[index].originalPosition.x + circleOffsetX;
                sprites[index].position.y = sprites[index].originalPosition.y + circleOffsetY;

                var scale = sprites[index].originalScale * circleScaleRatio;
                sprites[index].scale.set(scale, scale);
            }
            

            // for (var i = 0; i < Math.min(results.length,1); i++){
            //         var index = results[i].i;
            //         var tempMe = dataobj[index].slice(0);
            //          rotate(tempMe, angleMatch);

            //         for (var j = 0; j < tempMe.length; j++){
            //             if (j == 0) 
            //                  drawing.moveTo(tempMe[j*2]*0.1 + (i%16+1) * 80, tempMe[j*2+1]*0.1 + Math.floor(i/16 + 1) * 80 );
            //             else 
            //                  drawing.lineTo( tempMe[j*2]*0.1 + (i%16+1) * 80, tempMe[j*2+1]*0.1 + Math.floor(i/16 + 1) * 80 );                
            //         }
            //         //this.stroke();
                   

            //     }

            // for (var i = 0; i < pts.length; i++){
            //     if (i == 0){
            //         drawing.moveTo(pts[0][0] + 100, pts[0][1]);
            //     } else {
            //         drawing.lineTo(pts[i][0] + 100, pts[i][1]);
            //     }
            // }

            // Only update graphics on next pass if there is something
            // to animate
            updateGraphics = false;

                 if (bAmDrawing && sprites.length > 0) updateGraphics = true;
            else if (sprites.length > 1) updateGraphics = true;
            else if (sprites.length && !sprites[sprites.length-1].texture.baseTexture.hasLoaded) updateGraphics = true;
            else if (Math.abs(animatingCircle.x - targetX) > 1) updateGraphics = true;
            else if (Math.abs(animatingCircle.y - targetY) > 1) updateGraphics = true;
            else if (Math.abs(animatingCircle.r - targetR) > 1) updateGraphics = true;
         }
        renderer.render(stage);
        requestAnimationFrame( animate );
    }
    </script>

</body>
</html>