<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixi.js basic example</title>
        <script src="js/vptree.js"></script>
        <script src="js/vpTreeString.js"></script>  
        <!-- <script src="js/smallData.js"></script>  -->      
        <script src="js/dataInfo.js"></script>       <!-- heavy ! -->
        <script src="js/Smooth-0.1.7.js"></script>  <!-- smoothy dmoney -->
        <script src="js/Polyline.js"></script>  <!-- smoothy dmoney -->
        <script src="js/Utils.js"></script>  <!-- smoothy dmoney -->
        <script src="js/smallestEnclosingCircle.js"></script>  <!-- circle -->
        <script src="js/dat.gui.min.js"></script>
        <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:300,400" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Roboto Condensed', sans-serif;
        }

        #gradient-bottom {
            position: absolute;
            width: 100%;
            bottom: 0;
            height: 150px;
            background-size: auto 100%;
            background-image: url('../img/gradient_bottom_1pixel.png');
        }

        #info {
            color: white;
            position: absolute;
            bottom: 0px;
            text-transform: uppercase;
            font-size: 20pt;
            letter-spacing: 0.5pt;
            padding: 0 0 15px 15px;
        }
        #info a {
            color: white;
            text-decoration: none;
        }
        #info-attribution {
            text-transform: none;
            font-size: 9pt;
            letter-spacing: 0;
        }
    </style>
 
 
 
</head>
<body>

    <script src="pixi.js"></script>
    <script>


    var loadedJson = false;
    

    Object.defineProperty(Array.prototype, 'chunkArray', {
    value: function(chunkSize) {
        var array=this;
        return [].concat.apply([],
            array.map(function(elem,i) {
                return i%chunkSize ? [] : [array.slice(i,i+chunkSize)];
            })
        );
    }
    });


    // Generic function to load a file asynchronously
    function readTextFile(file, callback) {
        loadedJson = false;
        //console.log('Requesting file:', file);
        var rawFile = new XMLHttpRequest();
        rawFile.overrideMimeType("application/json");
        rawFile.open("GET", file, true);
        rawFile.onreadystatechange = function() {
            if (rawFile.readyState === 4) {
                callback(rawFile.status, rawFile.responseText);
            }
        }
        rawFile.send(null);
    }

    // Update DOM elements with new data
    function updateMetadata(data) {
        var line1 = data['line-1'] || '';
        var line2 = data['line-2'] || '';
        var attribution = data['attribution'] || '';
        var url = data['url'] || '';

        document.getElementById('info-line1').innerText = line1;
        document.getElementById('info-line2').innerText = line2;
        document.getElementById('info-line1').href = url;
        document.getElementById('info-line2').href = url;
        document.getElementById('info-attribution').innerText = attribution;
    }

    // Callback from AJAX request to get metadata for matched line
    function updateMetadataCallback(code, data) {
        if (code == 200) {
            matchedMetadata = JSON.parse(data);
        }
    };




    //----------------------------------------------------------
    // vpTree creation 
    // from cached files: 

    // todo: completely remove dataObj
    // completely load polylines throught this
    // 

    var vptrees = [];
    var polylines = [];
    var polylineCount = [];

    function loadNextTree(){
        readTextFile('data/' + vpTreeToLoad + '.json', loadVPTree);
    }

    Array.prototype.append = function(array)
    {
        this.push.apply(this, array)
    }


    var jsonData;
    var dataParseCount = 0;
    var parseWorkToDo = false;
    var polylinesTemp = [];

    function parseLoadVPTree(){

        if (!parseWorkToDo){
            return;
        }


        // otherwise let's do some work (accross frames) 

        //console.log("doing some work! " +  dataParseCount + " of " + jsonData["polylines"].length);

        var start =  dataParseCount;
        var end = Math.min(jsonData["polylines"].length,  dataParseCount + 50);

        //------------------------------------------------ do some work 
        var polylinePoints = jsonData["polylines"];
        
        for (j = start; j < end; j++){
            dataobj.push(polylinePoints[j]);
            ptsTemp = [];
            var x = 0;
            var y = 0;
            for (k = 0; k < polylinePoints[j].length/2; k++){
                x = polylinePoints[j][k*2];                      // converted to be relative...
                y = polylinePoints[j][k*2+1];
                pt = [];
                pt[0] = x;
                pt[1] = y;
                ptsTemp.push(pt);
            }
            var p = createPolyline(ptsTemp);
            p.init(true);
            polylinesTemp.push(p);
            polylines.push(p);  
        }
        

        dataParseCount = end;

        //------------------------------------------------ 
        if (end === jsonData["polylines"].length){          // we did it! 

            parseWorkToDo = false;
            polylineCount.push(polylinePoints.length);
            vpTreeString = eval('(' + jsonData["vpTree"] + ')');
            vptrees.push(VPTreeFactory.load(polylinesTemp, dist, vpTreeString));        
            vpTreeToLoad++;
            if (vpTreeToLoad < 5){
                window.setTimeout(loadNextTree, 10000);
            }
        }

    }

    function loadVPTree(code, data) {
        
        polylinesTemp = [];
        jsonData = JSON.parse(data);
        dataParseCount = 0;
        parseWorkToDo = true;

       
    }

    var vpTreeToLoad = 0;
    readTextFile('data/' + vpTreeToLoad + '.json', loadVPTree);

    //----------------------------------------------------------
    


    // Load a list of existing meta data ids since the filenames are actually indexed
    // from 0 - 1521 instead of using the id as the filename
    var metadataIDList = [];
    readTextFile('metadata-id-list.json', function(code, data) {
        metadataIDList = JSON.parse(data);
    });


    //-------------------------------------------------------------------
    //------------------------------------------------------------------- GUI
        
  var guiSettings = {
      "preset": "Default",
      "remembered": {
        "Default": {
          "0": {}
        },
        "Takashi": {
          "0": {
            "folders": {
              "line": {
                "preset": "Default",
                "closed": false,
                "folders": {}
              },
              "pulse": {
                "preset": "Default",
                "closed": false,
                "folders": {}
              },
              "scale/translate": {
                "preset": "Default",
                "closed": false,
                "folders": {}
              },
              "fade": {
                "preset": "Default",
                "closed": false,
                "folders": {}

              },
              "match": {
                "preset": "Default",
                "closed": false,
                "folders": {}
              }
            },
          },
          "closed": false,
          "folders": {}
        }
      }
    };
        
        
    var myGui;
    var Gui = function() {
        this.lineColor = 0xe8f700;
        this.lineOpacity = 0.75;
        this.lineWidth = 4;
        this.lineShadow = false;
        this.shadowDistance = 3;
        this.shadowBlur = 4;

        this.pulseWidth = 2;
        this.pulseSpeed = 10;
        this.pulseOpacityLow = 0.2;
        this.pulseOpacityHigh = 0.9;

        this.scaleSize = 0.22;
        this.scaleSpeed = 0.021;
        this.translateSpeed = 0.01;
        this.showEnclosingCircle = false;
        this.maxImageScale = 1.01;

        this.imgFadeInSpeed = 0.01;
        this.imgFadeOutSpeed = 0.01;
        this.bgFadeInSpeed = 0.004;
        this.bgFadeOutSpeed = 0.015;
        this.bgOpacity = 0.75;
        this.metadata = 0.15;

        this.badMatchThreshold = 0.25;
        
        this.loadFromCloud = true;
    };

    window.onload = function() {
        myGui = new Gui();

        var gui = new dat.GUI();
        var f1 = gui.addFolder('line');
        f1.addColor(myGui, 'lineColor');
        f1.add(myGui, 'lineOpacity', 0, 1);
        f1.add(myGui, 'lineWidth', 1, 10);
        var shadowToggle = f1.add(myGui, 'lineShadow');
        f1.add(myGui, 'shadowDistance', 0, 10);
        f1.add(myGui, 'shadowBlur', 0, 10);

        var f2 = gui.addFolder('pulse');
        f2.add(myGui, 'pulseWidth', 1, 10);
        f2.add(myGui, 'pulseOpacityLow', 0, 1);
        f2.add(myGui, 'pulseOpacityHigh', 0, 1);
        f2.add(myGui, 'pulseSpeed', 1, 20);

        var f3 = gui.addFolder('scale/translate');
        f3.add(myGui, 'scaleSize', 0.2, 0.5);
        f3.add(myGui, 'scaleSpeed', 0, 0.5);
        f3.add(myGui, 'translateSpeed', 0, 0.5);
        f3.add(myGui, 'showEnclosingCircle');
        f3.add(myGui, 'maxImageScale', 0.01, 4.01);
        
        var f4 = gui.addFolder('fade');
        f4.add(myGui, 'imgFadeInSpeed', 0, 0.2);
        f4.add(myGui, 'imgFadeOutSpeed', 0, 0.2);
        f4.add(myGui, 'bgFadeInSpeed', 0, 0.2);
        f4.add(myGui, 'bgFadeOutSpeed', 0, 0.2);
        f4.add(myGui, 'bgOpacity', 0, 1);
        f4.add(myGui, 'metadata', 0, 1);


        var f4 = gui.addFolder('match');
        f4.add(myGui, 'badMatchThreshold', 0.0, 1.0);

        // gui.add(myGui, 'loadFromCloud');
        
        gui.remember(myGui);

        shadowToggle.onFinishChange(updateLineShadow);
    };



    //-------------------------------------------------------------------
    //------------------------------------------------------------------- drawing related stuff
    var drawnCircle;
    var angleMatch = 0;
    var infoobj = JSON.parse(info);
    var dataobj = [];    ///= JSON.parse(data);

    var animatingCircle = {};
    var matchedMetadata = {};
    var textureHasLoaded = false;
    var metadataTargetOpacity = 0;
    var drawingAlpha = 1.0;
    var drawingAlphaTarget = 1.0;

    function returnPathForCircle(simpleArray){
        canvasPoints = [];
         for (var i = 0; i < simpleArray.length/2; i++){
            var tempX = simpleArray[i*2];
            var tempY = simpleArray[i*2+1];
           canvasPoints.push({
                x: tempX,
                y: tempY
            });
        }
        return canvasPoints;
    }

    function returnPathForArray(simpleArray){
        var path = [];
        for (var i = 0; i < simpleArray.length/2; i++){
            path[i] = {
                 x: simpleArray[i*2],
                y: simpleArray[i*2+1]
            };
        }
        return path;
    }

    function createPolyline(points) {
        ratio1D =  0.9;
        rotationInvariance =  Math.PI*2;
        normalPointCount =  80;
        normalSize = 200;
        var polyline = new Polyline(points);
        polyline.ratio1D = this.ratio1D;
        polyline.rotationInvariance = this.rotationInvariance;
        polyline.normalPointCount = this.normalPointCount;
        polyline.normalSize = this.normalSize;
        return polyline;
    }

    function returnNestedArray(simpleArray){
        var path = [];
        for (var i = 0; i < simpleArray.length/2; i++){
            input = [];
            input[0] = simpleArray[i*2];
            input[1] = simpleArray[i*2+1];
            path.push(input);
        }
        return path;
    }


    // // make data obj non relative: 
    // console.log('Make data obj non relative:', 'starting...');

    // for (i = 0; i < dataobj.length; i++){
    //     var x = 0;
    //     var y = 0;
    //     for (j = 0; j < dataobj[i].length/2; j++){
    //          x += dataobj[i][j*2];                      // converted to be relative...
    //          y += dataobj[i][j*2+1];
    //          dataobj[i][j*2] = x;
    //          dataobj[i][j*2+1] = y; 
    //     }
    // }

    // console.log('Make data obj non relative:', 'finished.');
    

    // convert to Polyline :) 
    // var polylines = [];
    // for (i = 0; i < dataobj.length; i++){
    //     ptsTemp = [];
    //     var x = 0;
    //     var y = 0;
    //     for (j = 0; j < dataobj[i].length/2; j++){
    //         x = dataobj[i][j*2];                      // converted to be relative...
    //         y = dataobj[i][j*2+1];
    //         pt = [];
    //         pt[0] = x;
    //         pt[1] = y;
    //         ptsTemp.push(pt);
    //     }
    //     var p = createPolyline(ptsTemp);
    //     p.init(true);
    //     polylines.push(p);
    //     //console.log(p);
    // }

    function dist(a, b) {
        return Utils.cosDistance(a.vector, b.vector);
    }


     function   rotate(vector1, radians) {
        var cos = Math.cos(radians);
        var sin = Math.sin(radians);
        for (var i = 0; i < vector1.length/2; i++) {
                x = vector1[i*2];
                y = vector1[i*2+1];
                //var p = this.points[i];
                var qx = x * cos - y * sin;
                var qy = x * sin + y * cos;
                vector1[i*2] = qx;
                vector1[i*2+1] = qy;
         }
    }


    function distNormalizedLines(vector1, vector2) {
        var a = vector1;
        var b = vector2;
        var distance = 0;
        var weight = 0;
        for (var i = 0; i < a.length/2; i++){
            var pct = i / (a.length/2);
            var scalar = 1.0+ (1.0 - Math.sin(pct * Math.PI))*10000.0;
            distance +=    scalar * Math.sqrt((b[i*2] - a[i*2])*(b[i*2] - a[i*2]) +  (b[i*2+1] - a[i*2+1])*(b[i*2+1] - a[i*2+1])); 
            weight += scalar;
        }
        return distance / weight;
    }

    //--------------------------------------------
    // split data obj 5 ways and make 5 vantage point trees. 
    // to test if checking against 5 is as good as checking one...
    //console.log("making a split to test multi vp trees");

    // var vptrees = [];
    // var polylinesSplit = [];
    // var amount = Math.ceil(dataobj.length / 5);
    // var dataObjChunked = dataobj.chunkArray(amount);
    // for (var i = 0; i < dataObjChunked.length; i++){

    //     var polylinesTemp = [];
    //     for (j = 0; j < dataObjChunked[i].length; j++){
    //         ptsTemp = [];
    //         var x = 0;
    //         var y = 0;
    //         for (k = 0; k < dataObjChunked[i][j].length/2; k++){
    //             x = dataObjChunked[i][j][k*2];                      // converted to be relative...
    //             y = dataObjChunked[i][j][k*2+1];
    //             pt = [];
    //             pt[0] = x;
    //             pt[1] = y;
    //             ptsTemp.push(pt);
    //         }
    //         var p = createPolyline(ptsTemp);
    //         p.init(true);
    //         polylinesTemp.push(p);
    //         //console.log(p);
    //     }
    //     polylinesSplit.push(polylinesTemp);
    //     vptrees.push(VPTreeFactory.build(polylinesSplit[i], dist));
    // }

    // this was used to export the data
    // for (var i = 0; i < dataObjChunked.length; i++){
    //      var objectForExport = {};
    //      objectForExport["polylines"] =  dataObjChunked[i];
    //      objectForExport["vpTree"] = vptrees[i].stringify();
    //      console.log(JSON.stringify(objectForExport));
    // }
    //  console.log(JSON.stringify(dataObjChunked[0]));
    //  console.log(JSON.stringify(polylinesSplit[0]));



    //console.log("done making a split to test multi vp trees " + vptrees.length);
    
    //--------------------------------------------

    // var vptree;
    // //vptree = VPTreeFactory.build(polylines, dist);

    // //var newType = {};


    // console.log('VPTreeFactory.load():', 'starting...');
    // vptree = VPTreeFactory.load(polylines,dist,vpTreeString );

    // //console.log(vptree.stringify());
    
    // console.log('VPTreeFactory.load():', 'finished.');
    //console.log(dataobj[0]);

    var drawing = false;
    var pts = [];
    var results = [];
    var ptsNew = [];

    var matched = false;
    pts = [];
    var linePulseCounter = 0;
    var bAmDrawing = false;
    var updateGraphics = false;
    var sprites = [];
    var backgroundImages = [];

    // Create the Renderer
    var w = window.innerWidth;
    var h = window.innerHeight;
    var renderer = PIXI.autoDetectRenderer(w, h, { backgroundColor : 0x000000, antialias: true });
    renderer.view.style.display = "block";
    document.body.appendChild(renderer.view);

    // Create the Stage, which is our root node of the scene
    var stage = new PIXI.Stage(0xFFFFFF, true);
    stage.interactive = true;
    stage.hitArea = new PIXI.Rectangle(0, 0, w, h);


    window.onresize = function (event){    
        var w = window.innerWidth;    
        var h = window.innerHeight;    //this part resizes the canvas but keeps ratio the same    
        renderer.view.style.width = w + "px";    
        renderer.view.style.height = h + "px";    //this part adjusts the ratio:    
        renderer.resize(w,h);
    }
    // resize things: 

//     var scene = new PIXI.DisplayObjectContainer();
 
// /**
//  * Add listeners for canvas scaling with window resizing and device rotation
//  */
// var resize = function () {
//         window.addEventListener('resize', rendererResize);
//         window.addEventListener('deviceOrientation', rendererResize);
// };

// /**
//  * Calculate the current window size and set the canvas renderer size accordingly
//  */
// var rendererResize = function () {
//     alert("hi");
//     var width = window.innerWidth,
//         height = window.innerHeight,
//         targetScale;

//     /**
//      * Set the canvas size and display size
//      * This way we can support retina graphics and make our game really crisp
//      */
//     canvas.width = width * window.devicePixelRatio;
//     canvas.height = height * window.devicePixelRatio;
//     canvas.style.width = width + 'px';
//     canvas.style.height = height + 'px';

//     /**
//      * Resize the PIXI renderer
//      * Let PIXI know that we changed the size of the viewport
//      */
//     renderer().resize(canvas.width, canvas.height);

//     /**
//      * Scale the canvas horizontally and vertically keeping in mind the screen estate we have
//      * at our disposal. This keeps the relative game dimensions in place.
//      */
//      if (height / targetHeight < width / targetWidth) {
//          scene.scale.x = scene.scale.y = height / targetHeight;
//      } else {
//          scene.scale.x = scene.scale.y = width / targetWidth;
//      }

//     /**
//      * Some sugar
//      * Set the x horizontal center point of the canvas after resizing.
//      * This should be used for engines which calculate object position from anchor 0.5/0.5
//      */
//     scene.pivot.y = -(width * (1 / scene.scale.y) / 2) * window.devicePixelRatio;
//     scene.pivot.x = -(width * (1 / scene.scale.x) / 2) * window.devicePixelRatio;

//     /**
//      * iOS likes to scroll when rotating - fix that 
//      */
//     window.scrollTo(0, 0);
// };


// // After the renderer and scene are initialized just call
// resize();








    // Handle device orientation change
    // window.addEventListener("deviceorientation", function() {
    //     console.log('orientation change!', window.orientation);
    //     console.log('inner width:', window.innerWidth, 'inner height:', window.innerHeight);
    //     renderer.resize(window.innerWidth, window.innerHeight);
    //     stage.hitArea = new PIXI.Rectangle(window.innerWidth, window.innerHeight);
    // }, true);

    // Line drawn out by the user
    var dropShadowFilter = new PIXI.filters.DropShadowFilter();
    var drawing = new PIXI.Graphics();
    stage.addChild(drawing);
    drawing.position.x = 0;
    drawing.position.y = 0;

    function updateLineShadow(val) {
        drawing.filters = val ? [ dropShadowFilter ] : null;
    }


    // loading: 
    var text = new PIXI.Text('Loading',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
    stage.addChild(text);
    text.position.x = 300;
    text.position.y = 300;


    var circleOffsetX;
    var circleOffsetY;
    var circleScaleRatio;
    var touchID;
    

    //------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------
    stage.mousedown = stage.touchstart = function(moveData) {

        if (bAmDrawing === true){
            return;
        }

        if (moveData.data.identifier === undefined){
            touchID = 0;
        } else {
            touchID = moveData.data.identifier;
        }

        drawingAlpha = 1.0;
        drawingAlphaTarget = 1.0;
        //console.log(moveData.data.identifier);
        matched = false;
        bAmDrawing = true;
        linePulseCounter = 0;
        textureHasLoaded = false;
        metadataTargetOpacity = 0;
        
        pts = [];
        pts.push(moveData.data.global.x);
        pts.push(moveData.data.global.y);
    
    };

    stage.mousemove = stage.touchmove = function(moveData) {




        if (bAmDrawing === true){

             if (moveData.data.identifier !== undefined) {
                if (touchID !== moveData.data.identifier){
                    return;
                }
             }

            pts.push(moveData.data.global.x);
            pts.push(moveData.data.global.y);

            if (pts.length > 60*2){
                pts.shift();
                pts.shift();
            } 

            updateGraphics = true;
        }

    };

    stage.mouseup = stage.mouseupoutside = stage.touchend = stage.touchendoutside = function(moveData) {


        if (moveData.data.identifier !== undefined) {
            if (touchID !== moveData.data.identifier){
                return;
            }
         }
             
        // if we weren't drawing (gui, etc) return;
         if (bAmDrawing === false){
            return;
        }


        bAmDrawing = false;




        // resample if we need to: 
        var ptsResampled = [];

        if (pts.length != 120){
            var xPts = [];
            var yPts = [];
            for (var i = 0; i < pts.length/2; i++){
                x = pts[i*2];
                y = pts[i*2+1];
                xPts[i] = x;
                yPts[i] = y;
            }
            //ptsResampled = [];       
            var xSmooth = Smooth(xPts);
            var ySmooth = Smooth(yPts);
            for (var i = 0; i < 60; i++){
                pctMe = i / 59.0;
                var newX = xSmooth(pctMe * (xPts.length -1));
                var newY = ySmooth(pctMe * (yPts.length -1));
                ptsResampled[i*2] = newX;
                ptsResampled[i*2+1] = newY;
            }
        } else {
            for (var i = 0; i < pts.length; i++){
                ptsResampled.push(pts[i]);
            }
        }

        ptsTemp = [];
        for (j = 0; j < ptsResampled.length/2; j++){
            x = ptsResampled[j*2];
            y = ptsResampled[j*2+1];
            pt = [];
            pt[0] = x;
            pt[1] = y;
            ptsTemp.push(pt);
        }

        ptsTemp2 = [];
        for (j = 0; j < ptsResampled.length/2; j++){
            x = ptsResampled[j*2];
            y = ptsResampled[j*2+1];
            pt = [];
            pt[0] = x;
            pt[1] = y;
            ptsTemp2.push(pt);
        }
        ptsTemp2.reverse();

        // make a circle so we can scale this circle 
        drawnCircle = makeCircle(returnPathForArray(ptsResampled));
        var p = createPolyline(ptsTemp);
        var p2 = createPolyline(ptsTemp2);
        p.init(true);
        p2.init(true);
        var resultsA; //= vptree.search(p, 1);
        //console.log('resultsA:', resultsA[0]);
        var resultsB; // = vptree.search(p2, 1);
        //console.log('resultsB:', resultsB[0]);

        if (vptrees.length == 0){
            console.log("we are still loading data, returning");
            return;
        }

        // check the multiple trees: 
        var minA = 1000000.0;
        var minAindex = -1;
        var minAnum = -1;

        var minB = 1000000.0;
        var minBindex = -1;
        var minBnum = -1;

        for (var i = 0; i < vptrees.length; i++){

            var multiResultsA = vptrees[i].search(p, 1);
            console.log('multiResultsA:', multiResultsA[0]);
            var multiResultsB = vptrees[i].search(p2, 1);
            console.log('multiResultsB:', multiResultsB[0]);

            if (i === 0){
                resultsA = multiResultsA;
                resultsB = multiResultsB;
            }

            if (multiResultsA[0].d < minA){
                minA = multiResultsA[0].d ;
                minAindex =  multiResultsA[0].i;
                minANum = i;
            }

            if (multiResultsB[0].d < minB){
                minB = multiResultsB[0].d ;
                minBindex =  multiResultsB[0].i;
                minBNum = i;
            }
        }

        var whichOneA = 0;
        var whichOneB = 0;

        for (var i = 0; i < minANum; i++){
            whichOneA += polylineCount[i];
        }
        whichOneA += minAindex;

        for (var i = 0; i < minBNum; i++){
            whichOneB += polylineCount[i];
        }
        whichOneB += minBindex;
        
        console.log(minA + " " + minB + " " + whichOneA + " " + whichOneB);

        console.log("overwriting original results");    


        resultsA[0].i = whichOneA;
        resultsA[0].d = minA;

        resultsB[0].i = whichOneB;
        resultsB[0].d = minB;
        
        console.log("done overwriting original results");

    
        if (resultsB[0].d < resultsA[0].d){
            results = resultsB;
            //pts.reverse();
            // reverse pair of two
            console.log("FLIP");
            for (j = 0; j < ptsResampled.length/2; j++){
                ptsResampled[j*2] = ptsTemp2[j][0];
                ptsResampled[j*2+1] = ptsTemp2[j][1];
            }      

        } else {
            results = resultsA;
        }

        console.log('results:', results[0]);


        var ptsScaled = ptsResampled.slice();
        var scaleMe = scale = 250.0 / drawnCircle.r;
        for (j = 0; j < ptsScaled.length/2; j++){
            ptsScaled[j*2] -= drawnCircle.x;
            ptsScaled[j*2+1] -= drawnCircle.y;
            ptsScaled[j*2] *= scaleMe;
            ptsScaled[j*2+1] *= scaleMe;
                 
        }



        var bestAngle = 0;
        var smallestDiff = 10000000;
        for (var i = 0; i < 300; i++){
            var angle = (i/300.0) * Math.PI * 2;
            var ptsRotated = dataobj[results[0].i].slice(0);

            rotate(ptsRotated, angle);
            rotatedDist = distNormalizedLines(ptsScaled, ptsRotated);

            if (rotatedDist < smallestDiff){
                smallestDiff = rotatedDist;
                bestAngle = angle;
            }
           
        }

        console.log("smallestDiff " + smallestDiff  + " results d " + results[0].d);

        if (results[0].d > myGui.badMatchThreshold){
            drawingAlphaTarget = 0.0;                       // fade out weird stuff 
        }

        // Pull ID from info obj, which actually stores IDs starting from 0
        var id = infoobj[results[0].i][0];
        console.log("loading metadata for id " + id);
        // Convert filename-based ID to "real" ID from spreadsheet

        // older: 
        // id = metadataIDList[id];
        // console.log("metadataIDList length ! " + metadataIDList.length);

        id = metadataIDList[id].toString();
        readTextFile('metadata/' + id.substr(0,1) + '/' + id + '.json', updateMetadataCallback);


        //console.log( "smallestDiff " + smallestDiff + " " + " bestAngle " + bestAngle );

        angleMatch = bestAngle;
        updateGraphics = true;


        console.log('TextureCache:', PIXI.utils.TextureCache);

        var random = Math.floor(Math.random()*1000);

        // Create a new Texture and Sprite from the matched image
        if (myGui.loadFromCloud)
            var url = 'http://storage.googleapis.com/navigator-media-usa/media/draw/v1/';
        else
            var url = '/';
        
        PIXI.loader.reset();

        console.log("loading num : "  + infoobj[results[0].i][0]);

        var texture = PIXI.Texture.fromImage(url + 'full/' + infoobj[results[0].i][0] + '.jpg');
        var sprite = new PIXI.Sprite(texture);
        sprite.alpha = 0;

        // Add the new Sprite to the stage
        // Old Sprits will fade out, calculated in animate()
        sprites.push(sprite);
        stage.addChild(sprite);

        // Move drawn line on top of images
        stage.removeChild(drawing);
        stage.addChild(drawing);

        // Positioning for matched image
        sprite.position.x = drawnCircle.x;
        sprite.position.y = drawnCircle.y;
        sprite.rotation = angleMatch;
        sprite.scale.x = drawnCircle.r / infoobj[results[0].i][3];
        sprite.scale.y = drawnCircle.r / infoobj[results[0].i][3];

        xPosOrig = infoobj[results[0].i][1];
        yPosOrig = infoobj[results[0].i][2];

        sprite.anchor.x = xPosOrig / 1800.0;
        sprite.anchor.y = yPosOrig / 1200.0;

        sprite.originalPosition = {};
        sprite.originalPosition.x = sprite.position.x;
        sprite.originalPosition.y = sprite.position.y;
        sprite.originalScale = sprite.scale.x;

        animatingCircle.x = drawnCircle.x;
        animatingCircle.y = drawnCircle.y;
        animatingCircle.r = drawnCircle.r;
        animatingCircle.origR = drawnCircle.r;



        // Update background image
        PIXI.loader.reset();
        url = 'http://storage.googleapis.com/navigator-media-usa/media/draw/v2/';
        var bg = new PIXI.Sprite.fromImage(url + 'blurredImages/' + infoobj[results[0].i][0] + '.jpg');
        bg.alpha = 0;
        // TODO Properly scale the background image to cover the background while maintaing
        // its aspect ratio. For now just stretch to fill
        bg.width = renderer.view.width;
        bg.height = renderer.view.height;
        backgroundImages.push(bg);
        stage.addChildAt(bg, 0);

        matched = true;

    //----------------------------

    }; 



    //------------------------------------------------------------------------------------------------

    animate();
    //requestAnimationFrame(animate);

    //console.log(sprite1.texture);

    var timef = 0;

    function animate() {
        

       
        parseLoadVPTree();  // always try to parse ! 


        if (vptrees.length > 0){
            text.position.x = -1000;
        }


        if (drawing === false && 
            matched === true){
            updateGraphics === true;
        }

        //------------------------------------------------------- drawing
        if (updateGraphics === true){
            drawing.clear();

            drawingAlpha = 0.98 * drawingAlpha + 0.02 * drawingAlphaTarget;
            //drawing.alpha = drawingAlpha;


            //console.log(drawing);
            dropShadowFilter.blur = myGui.shadowBlur;
            dropShadowFilter.distance = myGui.shadowDistance;

            if (!matched){
                drawing.lineStyle(myGui.lineWidth, myGui.lineColor, myGui.lineOpacity);

                for (var i = 0; i < pts.length/2; i++){
                    if (i == 0){
                        drawing.moveTo(pts[0], pts[1]);
                    } else {
                        drawing.lineTo(pts[i*2], pts[i*2+1]);
                    }
                }

                // Fade out old images to halfway
                for (var i = 0; i < sprites.length; i++) {
                    if (sprites[i].alpha >= 0.5) {
                        sprites[i].alpha -= myGui.imgFadeOutSpeed;
                    }
                }
                // Fade out background images
                for (var i = 0; i < backgroundImages.length; i++) {
                    backgroundImages[i].alpha -= myGui.bgFadeOutSpeed;
                }

            } else {

                // Update metadata UI when the texture loads

                var lastSprite = sprites[sprites.length-1];
                if (lastSprite.texture.baseTexture &&
                    lastSprite.texture.baseTexture.hasLoaded) {

                    if (!textureHasLoaded) {
                        console.log('Texture just finished loading!');
                        textureHasLoaded = true;
                        updateMetadata(matchedMetadata);
                        metadataTargetOpacity = 1;
                    }
                }

                // Set the line style based on our state
                // If the texture is loading, then it should pulse
                // Otherwise it's solid
                if (textureHasLoaded) {
                    drawing.lineStyle(myGui.lineWidth, myGui.lineColor, myGui.lineOpacity * drawingAlpha);
                } else {
                    linePulseCounter += (0.01 * myGui.pulseSpeed);
                    var sine = Math.sin(linePulseCounter);
                    var thickness = Utils.remap(sine, -1, 1, myGui.lineWidth - myGui.pulseWidth, myGui.lineWidth + myGui.pulseWidth);
                    var opacity = Utils.remap(sine, -1, 1, myGui.pulseOpacityLow, myGui.pulseOpacityHigh);
                    drawing.lineStyle(thickness, myGui.lineColor, opacity * drawingAlpha);
                }   



                var translateSpeed = myGui.translateSpeed;
                var scaleSpeed = myGui.scaleSpeed;

                var targetX = renderer.view.width * 0.5;
                var targetY = renderer.view.height * 0.5;
                if (renderer.view.width > renderer.view.height)
                    var targetR = renderer.view.height * myGui.scaleSize;
                else
                    var targetR = renderer.view.width * myGui.scaleSize;

            


                ///var targetR = renderer.view.height * myGui.scaleSize;
                if (sprites.length > 0){
                    var goToScale = sprites[sprites.length - 1].originalScale * (targetR / drawnCircle.r);
                    if (goToScale > myGui.maxImageScale){
                         
                         // 1.0 = A * (B / C); // solve for B
                         // 1.0/A = (B/C);
                         // B = (1.0/A) * C;
                         // omg algebra

                         targetR = (myGui.maxImageScale / sprites[sprites.length - 1].originalScale) * drawnCircle.r;
                    }
                }
                


                // Make sure the most recent matched image has loaded
                // Then begin calculating a lerped toward the target

                //console.log("scale factor = " + animatingCircle.origR + " " + targetR + " "  + 1.0 / (animatingCircle.origR / targetR));

                if (textureHasLoaded) {
                    animatingCircle.x = Utils.lerp(animatingCircle.x, targetX, translateSpeed);
                    animatingCircle.y = Utils.lerp(animatingCircle.y, targetY, translateSpeed);
                    animatingCircle.r = Utils.lerp(animatingCircle.r, targetR, scaleSpeed);
                }

                // Update offsets/scale ratios to move drawing line & image toward center
                circleOffsetX = animatingCircle.x - drawnCircle.x;
                circleOffsetY = animatingCircle.y - drawnCircle.y;
                circleScaleRatio = animatingCircle.r / drawnCircle.r;

                for (var i = 0; i < pts.length/2; i++){

                    // this is how we could scale and change the offset of the line.  zooming in to center seems good
                    // image can do the same thing since it's also set by drawn circle (above the end of mouse released)
                    
                    var x = pts[i*2] - drawnCircle.x;
                    var y = pts[i*2+1] - drawnCircle.y;

                    x *= circleScaleRatio;
                    y *= circleScaleRatio;

                    x += drawnCircle.x;
                    y += drawnCircle.y;

                    x += circleOffsetX;
                    y += circleOffsetY;


                    if (i == 0){
                        drawing.moveTo(x,y);
                    } else {
                        drawing.lineTo(x,y);
                    }
                }

                // Draw enclosing circle
                if (myGui.showEnclosingCircle) {
                    drawing.lineStyle(4, 0xff0000, 0.5);
                    drawing.drawCircle(animatingCircle.x, animatingCircle.y, animatingCircle.r);
                }
            }

            // Fade out old images
            if (sprites.length) {
                var endingIndex = bAmDrawing ? sprites.length - 1 : sprites.length - 2;
                for (var i = 0; i <= endingIndex; i++) {
                    sprites[i].alpha -= myGui.imgFadeOutSpeed;
                }
                // Fade in most recent image
                if (sprites[sprites.length-1].alpha < 1 && textureHasLoaded) {
                    sprites[sprites.length-1].alpha += myGui.imgFadeInSpeed;

                    // Make sure it doesn't exceed 1.0
                    if (sprites[sprites.length-1].alpha > 1)
                        sprites[sprites.length-1].alpha = 1;
                }

                // Remove invisible Sprites
                // Work in reverse to avoid the delete-while-iterating problem
                for (var i = sprites.length-1; i >= 0; i--) {
                    if (sprites[i].alpha < 0) {
                        // Delete 1 element at this index
                        stage.removeChild(sprites[i]);
                        
                        // do I remove this texture?
                        var amIsolo = true;
                        for (var j = 0; j < sprites.length; j++) {
                            if (j !== i){
                                if (sprites[i].texture.baseTexture === sprites[j].texture.baseTexture){
                                    amIsolo = false;
                                }
                            }
                        }

                        if (amIsolo === true){
                            sprites[i].texture.destroy(true);
                            sprites[i].destroy();
                        }
                        
                        sprites.splice(i, 1);
                    }
                }
            }

            // Fade out background images
           
            if (backgroundImages.length) {
                var endingIndex = bAmDrawing ? backgroundImages.length - 1 : backgroundImages.length - 2;
                for (var i = 0; i <= endingIndex; i++) {
                    backgroundImages[i].alpha -= myGui.bgFadeOutSpeed;
                }
                // Fade in most recent image
                if (backgroundImages[backgroundImages.length-1].alpha < myGui.bgOpacity) {
                    backgroundImages[backgroundImages.length-1].alpha += myGui.bgFadeInSpeed;

                    // Make sure it doesn't exceed 1.0
                    if (backgroundImages[backgroundImages.length-1].alpha > 1)
                        backgroundImages[backgroundImages.length-1].alpha = 1;
                }

                // Remove invisible Sprites
                // Work in reverse to avoid the delete-while-iterating problem
                for (var i = backgroundImages.length-1; i >= 0; i--) {
                    if (backgroundImages[i].alpha <= 0) {
                        // Delete 1 element at this index
                        stage.removeChild(backgroundImages[i]);
                        backgroundImages[i].destroy();
                        backgroundImages.splice(i, 1);
                    }
                }
            }

            // Scale & translate most recent matched image toward center
            if (sprites.length && !bAmDrawing) {
                var index = sprites.length - 1;
                sprites[index].position.x = sprites[index].originalPosition.x + circleOffsetX;
                sprites[index].position.y = sprites[index].originalPosition.y + circleOffsetY;

                var scale = sprites[index].originalScale * circleScaleRatio;

                //console.log("scale ???? " + sprites[index].originalScale );
                sprites[index].scale.set(scale, scale);
            }

            var infoElem = document.getElementById('info');
            if (Math.abs(metadataTargetOpacity - infoElem.style.opacity) > .01) {
                infoElem.style.opacity = Utils.lerp(infoElem.style.opacity, metadataTargetOpacity, myGui.metadata);
            }


            // Only update graphics on next pass if there is something
            // to animate

            // Keep this on for now since GUI changes won't take affect if we're not rendering
            // updateGraphics = false;
            updateGraphics = true;

            //      if (bAmDrawing && sprites.length > 0) updateGraphics = true;
            // else if (sprites.length > 1) updateGraphics = true;
            // else if (sprites.length && !sprites[sprites.length-1].texture.baseTexture.hasLoaded) updateGraphics = true;
            // else if (Math.abs(animatingCircle.x - targetX) > 1) updateGraphics = true;
            // else if (Math.abs(animatingCircle.y - targetY) > 1) updateGraphics = true;
            // else if (Math.abs(animatingCircle.r - targetR) > 1) updateGraphics = true;
         }
        renderer.render(stage);
        requestAnimationFrame( animate );



    }
    </script>

    <div id="gradient-bottom"></div>

    <div id="info">
        <div><a id="info-line1" href="" target="maps"></a></div>
        <div><a id="info-line2" href="" target="maps"></a></div>
        <div id="info-attribution"></div>
    </div>

</body>
</html>
